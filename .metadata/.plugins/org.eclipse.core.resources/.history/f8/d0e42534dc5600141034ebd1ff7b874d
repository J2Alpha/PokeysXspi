// VJoy.cpp : Defines the entry point for the console application.
//

#define VJOY_EXPORTS


#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <tchar.h>

int updatejoyaxis(short data,char axis);

extern "C" {
#include "VJoy.h"
}
int debugger=0;
bool CommsEnabled;
HANDLE hComms;
DWORD dwRetFlag;

int debugloopback=0;
unsigned short com0;
unsigned short com1;

JOYSTICK_STATE m_joyState[2] = { 0 };

//import utilib instead
void OpenComms(void);
//close port
void CloseComms(void);
//send chars
void SendToComPort(DWORD ResponseLength, unsigned char *Buffer);
//get chars
void ReceiveFromComPort(char *Buffer);
char name[]= "DCcVstic";
char serial[]= "1237942";
int main(int argc, char* argv[])
{
	VJoy_Initialize(name,serial);
	  
	m_joyState[0].XAxis = 0;
	m_joyState[0].YAxis = 0;
	m_joyState[0].ZAxis = 0;
	m_joyState[0].Buttons = 0xAAAAAAAA;//every other button pressed
	m_joyState[0].POV = (4 << 12) | (4 << 8) | (4 << 4) | 4;
	//send initial to uart
	for (int i = 0; i < 100; i++){
		//m_joyState[0].XAxis +=100;  //throttle 1 => 8 th bar down?
		//m_joyState[0].YAxis +=100; //throttle 2 => 7 the bar down?
		//m_joyState[0].ZAxis +=100; //throttle => 6th bar down?
		//todo read from uart
		Sleep(5);//allow qdec to stay up to date by sleeping occasionally
		//todo send 'B' to uart
		//m_joyState[0].XAxis +=100;  //throttle 1 => 8 th bar down?
		//m_joyState[0].YAxis +=100; //throttle 2 => 7 the bar down?
		//m_joyState[0].ZAxis +=100; //throttle => 6th bar down?

		Sleep(5);
		VJoy_UpdateJoyState(0, &m_joyState[0]);
		printf("updating %d \n",m_joyState[0].XAxis);
	}
	VJoy_UpdateJoyState(0, &m_joyState[0]);

	VJoy_Shutdown();
	printf("end , press any key to quit \n");
	fgetchar();
	return 0;
}
int updatejoyaxis(short data,char axis) {
	char buffer [100];
	switch(axis) {
	case 'x':
		m_joyState[0].XAxis =data;
		if(debugger)
		{
			printf(buffer, "updating X axis to %lu", data);
		}
		break;
	case 'y':
		m_joyState[0].YAxis =data;
		if(debugger)
		{
			printf(buffer, "updating Y axis to %lu", data);
		}
		break;
	case 'z':
		m_joyState[0].ZAxis =data;
		if(debugger)
		{
			printf(buffer, "updating Z axis to %lu", data);
		}
		break;
	default:
		printf("axis error, no such axis: %c \n",axis);
	}
	return 1;
}

int readin(){

	return 1;
}
void OpenComms(void)
{
    DCB Dcb;
    COMMTIMEOUTS CommTimeouts;
    char ErrorString[80];
    //char *PortString = "\\\\.\\COMx";

    if (hComms == 0)
    {
        //PortString[7] = (char) 4 + 48;
    	//TCHAR *pcCommPort = TEXT("COM4");
        hComms = CreateFile("\\\\.\\COM4",
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                            NULL);

        if (hComms == INVALID_HANDLE_VALUE)
        {
            sprintf(ErrorString, "CreateFile Error = %lu", GetLastError());
        }
        else
        {
            dwRetFlag = GetCommState(hComms, &Dcb);

            if (!dwRetFlag)
            {
                sprintf(ErrorString, "GetCommState Error = %lu", GetLastError());
            }

            Dcb.DCBlength = sizeof(Dcb);

            Dcb.BaudRate = CBR_57600;

            Dcb.ByteSize = 8;
            Dcb.Parity = NOPARITY;
            Dcb.StopBits = ONESTOPBIT;
            Dcb.fTXContinueOnXoff = TRUE;

            Dcb.fOutxCtsFlow = FALSE;//TRUE;                  // disable CTS output flow control
            Dcb.fOutxDsrFlow = FALSE;                  // disable DSR output flow control
            Dcb.fDtrControl = DTR_CONTROL_HANDSHAKE  /*DTR_CONTROL_DISABLE DTR_CONTROL_ENABLE*/;
            Dcb.fDsrSensitivity = FALSE;               // enable DSR sensitivity

            Dcb.fOutX = FALSE;                        // disable XON/XOFF out flow control
            Dcb.fInX = FALSE;                         // disable XON/XOFF in flow control
            Dcb.fErrorChar = FALSE;                   // disable error replacement
            Dcb.fNull = FALSE;                        // disable null stripping
            Dcb.fRtsControl = RTS_CONTROL_HANDSHAKE /* RTS_CONTROL_ENABLE  RTS_CONTROL_DISABLE*/;   //  enable RTS line
            Dcb.fAbortOnError = TRUE;                 // don't abort reads/writes on error

            dwRetFlag = SetCommState(hComms, &Dcb);
            if (!dwRetFlag)
            {
                printf( "SetCommState Error = %lu", GetLastError());

            }

            dwRetFlag = GetCommTimeouts(hComms, &CommTimeouts);
            if (!dwRetFlag)
            {
                printf("GetCommTimeouts Error = %lu", GetLastError());

            }

            CommTimeouts.ReadIntervalTimeout         = 50;    //Don't use interval timeouts
            CommTimeouts.ReadTotalTimeoutMultiplier  = 50;    //Don't use multipliers
            CommTimeouts.ReadTotalTimeoutConstant    = 50;    //150ms total read timeout
            CommTimeouts.WriteTotalTimeoutMultiplier = 5;//Don't use multipliers
            CommTimeouts.WriteTotalTimeoutConstant      = 5;//2200ms total write timeout

            dwRetFlag = SetCommTimeouts(hComms, &CommTimeouts);
            if (!dwRetFlag)
            {
                printf("SetCommTimeouts Error = %lu", GetLastError());

            }
        }
    }
    else
    {
        printf("Error comm port in use");
    }
}
//---------------------------------------------------------------------------

void CloseComms(void)
{
    if (hComms != 0)
    {
        CloseHandle(hComms);
        hComms = 0;
    }
    else
    {
        printf("Comm port already closed");
    }
}
//---------------------------------------------------------------------------

void SendToComPort(DWORD ResponseLength, unsigned char *Buffer)
{
    DWORD dwBytesWritten;

    if (hComms != 0)
        dwRetFlag = WriteFile(hComms, Buffer, ResponseLength, &dwBytesWritten, NULL);
    else
    {
        printf("Comm port not open");
    }
}
//---------------------------------------------------------------------------
void ReceiveFromComPort(char *Buffer)
{
    DWORD dwBytesRead = 0;

    if (hComms != 0)
    {
        while (dwBytesRead == 0)
            dwRetFlag = ReadFile(hComms, Buffer, sizeof(Buffer), &dwBytesRead, NULL);
    }
    else
    {
        printf("Comm port not open");
    }
}
